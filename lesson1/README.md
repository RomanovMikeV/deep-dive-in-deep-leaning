# Постановка задачи

В этом уроке мы решим задачу регрессии при помощи нейронной сети. Мы будем
предсказывать значение некоторой простой функции (например, синуса или косинуса)
в некоторой точке <img src="/lesson1/tex/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode&sanitize=true" align=middle width=9.39498779999999pt height=14.15524440000002pt/>.

Иными словами, мы сделаем сеть, которая делает аппроксимацию некоторой
неизвестной (скрытой) зависимости <img src="/lesson1/tex/7997339883ac20f551e7f35efff0a2b9.svg?invert_in_darkmode&sanitize=true" align=middle width=31.99783454999999pt height=24.65753399999998pt/>.

Стоит отметить, что это можно сделать с любой точностью при помощи сигмоидной
нейронной сети для ограниченной функции <img src="/lesson1/tex/7997339883ac20f551e7f35efff0a2b9.svg?invert_in_darkmode&sanitize=true" align=middle width=31.99783454999999pt height=24.65753399999998pt/> с конечным числом разрывов.

# Инструкции для решения
## Сделайте датасет

В этом уроке мы сделаем датасет сами. Для этого мы возьмем некоторую функцию <img src="/lesson1/tex/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode&sanitize=true" align=middle width=9.81741584999999pt height=22.831056599999986pt/>
(ограниченную, имеющую не больше, чем счетное количество разрывов), и сделаем
набор пар <img src="/lesson1/tex/20886c95cad07a2e07cc69a3cae30aee.svg?invert_in_darkmode&sanitize=true" align=middle width=91.05878099999998pt height=24.65753399999998pt/>, где <img src="/lesson1/tex/1cd32b0756da515bc59142b9318ff797.svg?invert_in_darkmode&sanitize=true" align=middle width=11.323291649999991pt height=14.15524440000002pt/> -- некоторый шум, который
мы будем генерировать сами. Причина, по которой мы добавляем шум в наши данные
заключается в том, что всегда, когда мы производим измерения, мы получаем
значение с некоторой точностью.

В реальной жизни у нас будет просто набор пар <img src="/lesson1/tex/9cb3b82be5418fbb7dad8a5c4ae38d9b.svg?invert_in_darkmode&sanitize=true" align=middle width=34.88399804999999pt height=14.15524440000002pt/>, в качестве датасета,
по которым необходимо восстановить скрытую зависимость <img src="/lesson1/tex/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode&sanitize=true" align=middle width=9.81741584999999pt height=22.831056599999986pt/> такую, что
<p align="center"><img src="/lesson1/tex/2398b6b54c85aadd6104d17fb77bebbf.svg?invert_in_darkmode&sanitize=true" align=middle width=104.3349714pt height=16.438356pt/></p>.

Для выполнения этого задания создайте файл sine_dataset.py и
1) сделайте в нем два класса: ```DataSetIndex``` и ```DataSet```

2) для класса ```DataSetIndex``` сделайте метод
```__init__(self, seed=0, n_items=1000, low=-10.0, high=10.0, noise=0.1)```.
Здесь инициализируйте генератор случайных чисел numpy значением seed,
создайте случайный набор координат, равномерно распределенных от ```low``` до
```high```,
посчитайте в этих координатах значение функции <img src="/lesson1/tex/fb9dd87ee5c46cc6f1bac5ad989387d4.svg?invert_in_darkmode&sanitize=true" align=middle width=45.416004149999985pt height=24.65753399999998pt/>, сгенерируйте
вектор шума соответствующего размера (нормальный шум со матожиданием 0 и
стандартным отклонением ```noise_level```), добавьте шум к значениям функции,
разбейте координаты и значения на три куска: train, valid и test (valid и test
должны составлять по 10% от всей выборки).
Сделайте переменную order для каждого куска датасета. Для train сделайте
перемешивание индексов, для valid и test можете оставить индексы в
исходном порядке.

3) для класса ```DataSetIndex``` сделайте метод
```shuffle(self)```. Этот метод будет вызываться после каждой эпохи и
перемешивать тренировочную выборку для дальнейшего обучения.

4) для класса ```DataSet``` сделайте метод
```__init__(self, ds_index, mode='train')```. В нем сохраните ds_index и mode
в обьект ```self``` класса ```DataSet```.

5) для класса ```DataSet``` сделайте метод ```__len__(self)```, который будет
возвращать количество примеров в ```self```. Помните, что количество примеров
разное для ```train```, ```valid``` и ```test``` кусков датасета.

6) для класса ```DataSet``` сделайте метод ```__getitem__(self, index)```,
который вернет два списка: список входных значений и список целевых значений
выходов. В этой задаче в каждом списке должно быть по одному числу.
Помните, что количество примеров
разное для ```train```, ```valid``` и ```test``` кусков датасета.

7) протестируйте датасет. Посмотрите, что возвращает DataSet при индексации
(например, при вытаскивании элемента с номером 0). Проверьте, что DataSet
работает во всех режимах (```train```, ```valid```, ```test```) для всех
индексов. Посмотрите, как выглядят наши данные: сделайте график при помощи
Jupyter Notebook значений <img src="/lesson1/tex/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode&sanitize=true" align=middle width=9.39498779999999pt height=14.15524440000002pt/> и <img src="/lesson1/tex/7997339883ac20f551e7f35efff0a2b9.svg?invert_in_darkmode&sanitize=true" align=middle width=31.99783454999999pt height=24.65753399999998pt/>.

## Create a Model / Сделайте модель

Мы уже сделали скрипт датасета -- это половина работы. Вторая половина --
определиться с архитектурой модели, лосс-функцией, метриками, оптимизатором.

1) Для начала сделаем архитектуру модели. Для этого определим класс ```Model``` в
```model.py```. Он должен быть унаследован от класса ```torch.nn.Module```.

2) В этом классе сделайте функцию ```__init__```, в которой будут определены все
элементы архитектуры. В нашем случае нейронная сеть будет состоять из двух
линейных слоев (скрытого и выходного). Нужно создать эти слои в __init__.
Количество скрытых нейронов можно сделать параметром сети.

3) Далее, нужно определить, как будет вычисляться результат работы сети.
Создайте метод forward в классе Model. Этот метод принимает один аргумент
(список входов в сеть) и возвращает один результат (список выходов из сети).
Производите вычисления следующим образом:
вход -> скрытый слой -> сигмоида -> выходной слой.

Таким образом, мы сделали нашу нейронную сеть.

### Сделайте обработчик модели (Socket)

В этом классе находится вся информация о том, как взаимодействовать с моделью.

В этом классе нужно определить следующие методы: ```__init__``` -- конструктор,
```criterion``` -- лосс-функция, ```metrics``` -- метрики. Остальное определять
в этом задании не обязательно.

1) Сделайте метод ```__init__(self, model)```: сохраните модель в поле self.model,
определите тренируемые слои (поле ```self.train_modules```, в этом задании это вся
модель, поэтому можно в качестве тренируемых слоев передать ```self.model```),
задайте оптимизатор self.optimizer (пусть в нашем случае это будет Adam со
скоростью обучения ```3.0e-4```).

2) Сделайте метод ```criterion(self, output, target)```. Сюда будут приходить
списки результатов работы модели и целевых значений. В нашем случае эти списки
будут содержать по одному тензору. В нашем случае функцией ошибки будет
среднеквадратичное отклонение (Mean Squared Error, MSE). Используя операции
пакета torch расчитайте значение MSE между output[0] и target[0] и верните
результат. Формула для расчета среднеквадратичной ошибки:

<p align="center"><img src="/lesson1/tex/6e1d54a974cb6dd25634e065908fddbb.svg?invert_in_darkmode&sanitize=true" align=middle width=265.7545737pt height=47.806078649999996pt/></p>

3) Сделайте метод ```metrics(self, output, target)```. Сюда будут приходить точно
такие же списки, как и в метод ```criterion```. В этом задании мы будем
использовать метрику "доля точек с ошибкой меньше заданной":

<p align="center"><img src="/lesson1/tex/890c292877152a94f346c8835bfbe065.svg?invert_in_darkmode&sanitize=true" align=middle width=220.16945280000002pt height=47.806078649999996pt/></p>

Здесь <img src="/lesson1/tex/8e6f8772884838ad7db8233311f53511.svg?invert_in_darkmode&sanitize=true" align=middle width=37.47063044999999pt height=31.50689519999998pt/> -- результат работы нейронной сети в точке <img src="/lesson1/tex/9fc20fb1d3825674c6a279cb0d5ca636.svg?invert_in_darkmode&sanitize=true" align=middle width=14.045887349999989pt height=14.15524440000002pt/>, <img src="/lesson1/tex/2b442e3e088d1b744730822d18e7aa21.svg?invert_in_darkmode&sanitize=true" align=middle width=12.710331149999991pt height=14.15524440000002pt/> --
таргетное значение. Возьмите <img src="/lesson1/tex/ccc8c36bd75b0a3fd820174d730dea02.svg?invert_in_darkmode&sanitize=true" align=middle width=150.96466109999997pt height=21.18721440000001pt/>. Это и будут
наши метрики. Верните словарь из метрик.
